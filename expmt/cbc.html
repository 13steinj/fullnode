<!DOCTYPE html><html lang="en"><head><title>expmt/cbc</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="expmt/cbc"><meta name="groc-project-path" content="lib/expmt/cbc.js"><meta name="groc-github-url" content="https://github.com/ryanxcharles/fullnode"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/ryanxcharles/fullnode/blob/master/lib/expmt/cbc.js">lib/expmt/cbc.js</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> Random = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../random'</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cipher Block Chaining
<a href="http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher-block_chaining_.28CBC.29">http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher-block_chaining_.28CBC.29</a></p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> CBC = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CBC</span><span class="hljs-params">(blockcipher, cipherkeybuf, ivbuf)</span> {</span>
  <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> CBC))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CBC(blockcipher, cipherkeybuf, ivbuf);

  <span class="hljs-keyword">this</span>.blockcipher = blockcipher;
  <span class="hljs-keyword">this</span>.cipherkeybuf = cipherkeybuf;
  <span class="hljs-keyword">this</span>.ivbuf = ivbuf;
};

CBC.buf2blockbufs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf, blocksize)</span> {</span>
  <span class="hljs-keyword">var</span> bytesize = blocksize / <span class="hljs-number">8</span>;
  <span class="hljs-keyword">var</span> blockbufs = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= buf.length / bytesize; i++) {
    <span class="hljs-keyword">var</span> blockbuf = buf.slice(i * bytesize, i * bytesize + bytesize);

    <span class="hljs-keyword">if</span> (blockbuf.length &lt; blocksize)
      blockbuf = CBC.pkcs7pad(blockbuf, blocksize);

    blockbufs.push(blockbuf);
  }

  <span class="hljs-keyword">return</span> blockbufs;
};

CBC.blockbufs2buf = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(blockbufs, blocksize)</span> {</span>
  <span class="hljs-keyword">var</span> bytesize = blocksize / <span class="hljs-number">8</span>;

  <span class="hljs-keyword">var</span> last = blockbufs[blockbufs.length - <span class="hljs-number">1</span>];
  last = CBC.pkcs7unpad(last);
  blockbufs[blockbufs.length - <span class="hljs-number">1</span>] = last;

  <span class="hljs-keyword">var</span> buf = Buffer.concat(blockbufs);

  <span class="hljs-keyword">return</span> buf;
};

CBC.encrypt = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(messagebuf, ivbuf, blockcipher, cipherkeybuf)</span> {</span>
  <span class="hljs-keyword">var</span> blocksize = ivbuf.length * <span class="hljs-number">8</span>;
  <span class="hljs-keyword">var</span> blockbufs = CBC.buf2blockbufs(messagebuf, blocksize);
  <span class="hljs-keyword">var</span> encbufs = CBC.encryptblocks(blockbufs, ivbuf, blockcipher, cipherkeybuf);
  <span class="hljs-keyword">var</span> encbuf = Buffer.concat(encbufs);
  <span class="hljs-keyword">return</span> encbuf;
};

CBC.decrypt = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(encbuf, ivbuf, blockcipher, cipherkeybuf)</span> {</span>
  <span class="hljs-keyword">var</span> blocksize = ivbuf.length * <span class="hljs-number">8</span>;
  <span class="hljs-keyword">var</span> bytesize = ivbuf.length;
  <span class="hljs-keyword">var</span> encbufs = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; encbuf.length / bytesize; i++) {
    encbufs.push(encbuf.slice(i * bytesize, i * bytesize + bytesize));
  }
  <span class="hljs-keyword">var</span> blockbufs = CBC.decryptblocks(encbufs, ivbuf, blockcipher, cipherkeybuf);
  <span class="hljs-keyword">var</span> buf = CBC.blockbufs2buf(blockbufs, blocksize);
  <span class="hljs-keyword">return</span> buf;
};

CBC.encryptblock = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(blockbuf, ivbuf, blockcipher, cipherkeybuf)</span> {</span>
  <span class="hljs-keyword">var</span> xorbuf = CBC.xorbufs(blockbuf, ivbuf);
  <span class="hljs-keyword">var</span> encbuf = blockcipher.encrypt(xorbuf, cipherkeybuf);
  <span class="hljs-keyword">return</span> encbuf;
};

CBC.decryptblock = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(encbuf, ivbuf, blockcipher, cipherkeybuf)</span> {</span>
  <span class="hljs-keyword">var</span> xorbuf = blockcipher.decrypt(encbuf, cipherkeybuf);
  <span class="hljs-keyword">var</span> blockbuf = CBC.xorbufs(xorbuf, ivbuf);
  <span class="hljs-keyword">return</span> blockbuf;
};

CBC.encryptblocks = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(blockbufs, ivbuf, blockcipher, cipherkeybuf)</span> {</span>
  <span class="hljs-keyword">var</span> encbufs = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; blockbufs.length; i++) {
    <span class="hljs-keyword">var</span> blockbuf = blockbufs[i];
    <span class="hljs-keyword">var</span> encbuf = CBC.encryptblock(blockbuf, ivbuf, blockcipher, cipherkeybuf);

    encbufs.push(encbuf);

    ivbuf = encbuf;
  }

  <span class="hljs-keyword">return</span> encbufs;
};

CBC.decryptblocks = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(encbufs, ivbuf, blockcipher, cipherkeybuf)</span> {</span>
  <span class="hljs-keyword">var</span> blockbufs = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; encbufs.length; i++) {
    <span class="hljs-keyword">var</span> encbuf = encbufs[i];
    <span class="hljs-keyword">var</span> blockbuf = CBC.decryptblock(encbuf, ivbuf, blockcipher, cipherkeybuf);

    blockbufs.push(blockbuf);

    ivbuf = encbuf;
  }

  <span class="hljs-keyword">return</span> blockbufs;
};

CBC.pkcs7pad = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf, blocksize)</span> {</span>
  <span class="hljs-keyword">var</span> bytesize = blocksize / <span class="hljs-number">8</span>;
  <span class="hljs-keyword">var</span> padbytesize = bytesize - buf.length;
  <span class="hljs-keyword">var</span> pad = <span class="hljs-keyword">new</span> Buffer(padbytesize);
  pad.fill(padbytesize);
  <span class="hljs-keyword">var</span> paddedbuf = Buffer.concat([buf, pad]);
  <span class="hljs-keyword">return</span> paddedbuf;
};

CBC.pkcs7unpad = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(paddedbuf, blocksize)</span> {</span>
  <span class="hljs-keyword">var</span> bytesize = blocksize / <span class="hljs-number">8</span>;
  <span class="hljs-keyword">var</span> padbytesize = bytesize - paddedbuf.length;
  <span class="hljs-keyword">var</span> padlength = paddedbuf[paddedbuf.length - <span class="hljs-number">1</span>];
  <span class="hljs-keyword">var</span> padbuf = paddedbuf.slice(paddedbuf.length - padlength, paddedbuf.length);
  <span class="hljs-keyword">var</span> padbuf2 = <span class="hljs-keyword">new</span> Buffer(padlength);
  padbuf2.fill(padlength);
  <span class="hljs-keyword">if</span> (padbuf.toString(<span class="hljs-string">'hex'</span>) !== padbuf2.toString(<span class="hljs-string">'hex'</span>))
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'invalid padding'</span>);
  <span class="hljs-keyword">return</span> paddedbuf.slice(<span class="hljs-number">0</span>, paddedbuf.length - padlength);
};

CBC.xorbufs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(buf1, buf2)</span> {</span>
  <span class="hljs-keyword">if</span> (buf1.length !== buf2.length)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'bufs must have the same length'</span>);

  <span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Buffer(buf1.length);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; buf1.length; i++) {
    buf[i] = buf1[i] ^ buf2[i];
  }

  <span class="hljs-keyword">return</span> buf;
};

module.exports = CBC;</div></div></div></div></body></html>